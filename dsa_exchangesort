using System;
using System.Diagnostics;
using System.Text;

namespace ConsoleApp3
{
    internal class Program
    {
        // ==============================
        // HÀM KIỂM TRA TÍNH ỔN ĐỊNH CỦA THUẬT TOÁN
        // ==============================
        static bool IsStable(int[] userArray)
        {
            // Gắn thêm chỉ số gốc để theo dõi thứ tự ban đầu
            var arr = new (int value, int originalIndex)[userArray.Length];
            for (int i = 0; i < userArray.Length; i++)
                arr[i] = (userArray[i], i);

            var sorted = (ValueTuple<int, int>[])arr.Clone();

            // Sắp xếp kiểu Exchange Sort (có thể thay bằng thuật toán khác)
            for (int i = 0; i < sorted.Length - 1; i++)
            {
                for (int j = i + 1; j < sorted.Length; j++)
                {
                    if (sorted[j].Item1 < sorted[i].Item1)
                        Swap(ref sorted[j], ref sorted[i]);
                }
            }

            // Nếu 2 phần tử bằng nhau mà vị trí bị đảo → không ổn định
            for (int i = 0; i < sorted.Length - 1; i++)
            {
                if (sorted[i].Item1 == sorted[i + 1].Item1 &&
                    sorted[i].Item2 > sorted[i + 1].Item2)
                {
                    return false;
                }
            }

            return true;
        }

        // ==============================
        // HÀM HOÁN ĐỔI CHUNG
        // ==============================
        static void Swap<T>(ref T a, ref T b)
        {
            T temp = a;
            a = b;
            b = temp;
        }

        // ==============================
        //  THUẬT TOÁN EXCHANGE SORT (TỔNG QUÁT)
        // ==============================
        static void ExchangeSort<T>(T[] arr) where T : IComparable<T>
        {
            for (int i = 0; i < arr.Length - 1; i++)
            {
                for (int j = i + 1; j < arr.Length; j++)
                {
                    if (arr[j].CompareTo(arr[i]) < 0)
                        Swap(ref arr[j], ref arr[i]);
                }
            }
        }

        // ==============================
        // LỚP HỖ TRỢ ĐO THỜI GIAN
        // ==============================
        public static class Timing
        {
            /// <summary>
            /// Đo thời gian trung bình khi chạy thuật toán sắp xếp (chạy nhiều lần)
            /// </summary>
            public static double Measure<T>(
                Action<T[]> sortAlgorithm,
                T[] arr,
                int repeat,
                string caseName
            ) where T : IComparable<T>
            {
                Stopwatch sw = new Stopwatch();
                double totalMs = 0;

                for (int i = 0; i < repeat; i++)
                {
                    // Tạo bản sao mảng để đảm bảo công bằng giữa các lần đo
                    T[] copy = new T[arr.Length];
                    Array.Copy(arr, copy, arr.Length);

                    sw.Restart();
                    sortAlgorithm(copy);
                    sw.Stop();

                    totalMs += sw.Elapsed.TotalMilliseconds;
                }

                double avg = totalMs / repeat;
                Console.WriteLine($"→ {caseName,-12}: {avg,10:F5} ms (Trung bình {repeat} lần)");
                return avg;
            }

            // ====== Các hàm sinh dữ liệu ======
            public static int[] GenerateSortedArray(int n)
            {
                int[] arr = new int[n];
                for (int i = 0; i < n; i++) arr[i] = i;
                return arr;
            }

            public static int[] GenerateRandomArray(int n)
            {
                Random rnd = new Random();
                int[] arr = new int[n];
                for (int i = 0; i < n; i++) arr[i] = rnd.Next(0, 100);
                return arr;
            }

            public static int[] GenerateReversedArray(int n)
            {
                int[] arr = new int[n];
                for (int i = 0; i < n; i++) arr[i] = n - i;
                return arr;
            }
        }

        // ==============================
        //  HÀM MAIN – THỰC HIỆN CHƯƠNG TRÌNH
        // ==============================
        static void Main(string[] args)
        {
            Console.OutputEncoding= Encoding.UTF8;
            int n = 3000;      // Kích thước mảng (≥ 1000 phần tử)
            int repeat = 1000; // Số lần chạy để lấy trung bình

            // Tạo các trường hợp dữ liệu
            int[] best = Timing.GenerateSortedArray(n);
            int[] average = Timing.GenerateRandomArray(n);
            int[] worst = Timing.GenerateReversedArray(n);

            Console.WriteLine("══════════════════════════════════════════════════════════");
            Console.WriteLine($" ĐO HIỆU NĂNG THUẬT TOÁN EXCHANGE SORT ({n} phần tử, {repeat} lần lặp)");
            Console.WriteLine("──────────────────────────────────────────────────────────");

            // Đo 3 trường hợp
            double bestTime = Timing.Measure(ExchangeSort, best, repeat, "Trường hợp tốt nhất");
            double avgTime = Timing.Measure(ExchangeSort, average, repeat, "Trường hợp trung bình");
            double worstTime = Timing.Measure(ExchangeSort, worst, repeat, "Trường hợp tệ nhất");

            Console.WriteLine("──────────────────────────────────────────────────────────");
            Console.WriteLine(" KẾT QUẢ TỔNG HỢP:");
            Console.WriteLine($"Tốt nhất  : {bestTime:F5} ms");
            Console.WriteLine($"Trung bình: {avgTime:F5} ms");
            Console.WriteLine($"Tệ nhất   : {worstTime:F5} ms");

            // Kiểm tra tính ổn định
            Console.WriteLine("──────────────────────────────────────────────────────────");
            bool stable = IsStable(new int[] { 2, 3, 2, 1, 3, 2 });
            Console.WriteLine($"Tính ổn định của Exchange Sort: {(stable ? "ỔN ĐỊNH" : "KHÔNG ỔN ĐỊNH")}");
            Console.WriteLine("══════════════════════════════════════════════════════════");
        }
    }
}
